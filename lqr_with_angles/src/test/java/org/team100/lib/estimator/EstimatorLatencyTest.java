package org.team100.lib.estimator;

import org.junit.jupiter.api.Test;
import org.team100.lib.controller.FeedbackControl;
import org.team100.lib.controller.GainCalculator;
import org.team100.lib.controller.LinearizedPlantInversionFeedforward;
import org.team100.lib.fusion.LinearPooling;
import org.team100.lib.fusion.VarianceWeightedLinearPooling;
import org.team100.lib.math.RandomVector;
import org.team100.lib.system.examples.DoubleIntegratorRotary1D;

import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.Nat;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.Vector;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N2;

/**
 * Illustrates delayed measurements and what to do with them.
 * 
 * TODO: actually delay the measurements. :-)
 * 
 * For the data generated by these tests, look here:
 * 
 * https://docs.google.com/spreadsheets/d/1miehTmvbdRFs49wy2x8u_3SqVKrNw-oJB5Dv5-uQYo0
 * 
 * Timing
 * 
 * Sensor delay has several components:
 * * position sample rate
 * * velocity window width
 * * velocity averaging
 * * reporting rate
 * 
 * Using SparkMax velocity measurement is described here
 * 
 * https://docs.revrobotics.com/sparkmax/software-resources/configuration-parameters
 * 
 * the sparkmax measures velocity with a two-step process.
 * 
 * first it samples velocity using the current position and a past position, and
 * then it averages the past N samples.
 * 
 * the sparkmax takes a position measurement every 500 us.
 * 
 * kEncoderSampleDelta is the number of position measurements to look back.
 * 
 * for the built-in sensor it must be between 8 and 64, default is 32 which
 * means 0.016s between samples.
 * 
 * kEncoderAverageDepth is the number of velocity samples to average.
 * for the built-in sensor it is 1,2,4, or 8 (the default); it just averages the
 * past N samples.
 * 
 * so using the default dt and the default average depth, the edge of the window
 * is 0.128s ago.
 * 
 * The SparkMax reporting frequency is described here:
 * 
 * https://docs.revrobotics.com/sparkmax/operating-modes/control-interfaces
 * 
 * Velocity is reported via CAN as part of Periodic Status 1, which has a
 * default rate of 20ms
 * Position is reported via CAN as part of Periodic Status 2, which has a
 * default rate of 20ms.
 * 
 * these rates can be increased a little, like to 10ms if the rio is running a
 * fast loop.
 * 
 * but for now use 20ms.
 * 
 * assume that the marshalling delay is zero.
 * 
 * Another example of measurement delay is the gyro
 * 
 * https://pdocs.kauailabs.com/navx-mxp/wp-content/uploads/2019/02/navx-mxp_robotics_navigation_sensor_user_guide.pdf
 * 
 * this specifies 1ms latency for the USB interface, and 200Hz sampling, and
 * also suggests that the on-board filter is EKF, which means it should have
 * pretty low latency relative to the sampling frequency?
 */
public class EstimatorLatencyTest {
    private static final double kDelta = 0.001;

    private static final long kUsecPerSimLoop = 2000; // 2 ms per simulation loop
    private static final long kUsecPerRioLoop = 20000; // 20 ms per rio loop
    private static final double kSecPerUsec = 1e-6;
    private static final double kSecPerRioLoop = kUsecPerRioLoop * kSecPerUsec;

    public static class CompleteState {
        // int step;
        long systemTimeMicrosec; // from FPGAtime

        double actualTimeSec() {
            return systemTimeMicrosec * kSecPerUsec;
        }

        double actualPosition;
        double actualVelocity;
        double actualAcceleration;

        double observationTimeSec; // valid time this observation represents
        double observedPosition;
        double observedVelocity;
        double observedAcceleration; // for these tests this is intended to match u.

        double predictionTimeSec; // time in the future this prediction is intended for
        double predictedPosition;
        double predictedVelocity;

        double residualPosition;
        double residualVelocity;

        double controlU;
    }

    public static abstract class Scenario {
        final CompleteState state;
        final IntegratingPredictor<N2, N1, N2> predictor;
        final PointEstimator<N2, N1, N2> pointEstimator;
        final LinearPooling<N2> pooling;
        final LinearizedPlantInversionFeedforward<N2, N1, N2> feedforward;
        final FeedbackControl<N2, N1, N2> controller;
        final DoubleIntegratorRotary1D system;

        public Scenario() {
            system = new DoubleIntegratorRotary1D();
            state = initial();
            predictor = new IntegratingPredictor<>(system);
            pointEstimator = new PointEstimator<>(system);
            pooling = new VarianceWeightedLinearPooling<>();
            feedforward = new LinearizedPlantInversionFeedforward<>(system);
            controller = newController();
            label();
            printHeader();
        }

        abstract void label();

        abstract double position(double timeSec);

        abstract double velocity(double timeSec);

        abstract double acceleration(double timeSec);

        /**
         * Update the actual state of the physical system.
         */
        void updateActual() {
            state.actualPosition = position(state.actualTimeSec());
            state.actualVelocity = velocity(state.actualTimeSec());
            state.actualAcceleration = acceleration(state.actualTimeSec());
        }

        /**
         * For now, observations are perfect and instantaneous.
         */
        void updateObservation() {
            state.observedPosition = state.actualPosition;
            state.observedVelocity = state.actualVelocity;
            state.observedAcceleration = state.actualAcceleration;
        }

        /**
         * Specify the desired future state.
         */
        Vector<N2> nextReference() {
            // TODO: make this dt/2 for midpoint actuation
            double futureTimeSec = state.actualTimeSec() + kSecPerRioLoop;
            double referencePosition = position(futureTimeSec);
            double referenceVelocity = velocity(futureTimeSec);
            return VecBuilder.fill(referencePosition, referenceVelocity);
        }

        /**
         * analytical future state derivative
         */
        Vector<N2> nextRDot() {
            double futureTimeSec = state.actualTimeSec() + kSecPerRioLoop;
            double referenceVelocity = velocity(futureTimeSec);
            double referenceAcceleration = acceleration(futureTimeSec);
            return VecBuilder.fill(referenceVelocity, referenceAcceleration);
        }

        CompleteState initial() {
            double initialPosition = position(0);
            double initialVelocity = velocity(0);
            double initialAcceleration = acceleration(0);
            CompleteState state = new CompleteState();

            state.systemTimeMicrosec = 0l;
            // state.actualTimeSec = 0;

            state.actualPosition = initialPosition;
            state.actualVelocity = initialVelocity;
            state.actualAcceleration = initialAcceleration;

            state.observedPosition = initialPosition;
            state.observedVelocity = initialVelocity;
            state.observedAcceleration = initialAcceleration;

            state.predictedPosition = initialPosition;
            state.predictedVelocity = initialVelocity;

            state.residualPosition = 0;
            state.residualVelocity = 0;

            state.controlU = initialAcceleration;
            return state;
        }

        void execute() {
            RandomVector<N2> xhat = new RandomVector<>(VecBuilder.fill(0, 0), new Matrix<>(Nat.N2(), Nat.N2()));
            for (long step = 0; step < 2000; ++step) {
                state.systemTimeMicrosec = step * kUsecPerSimLoop;
                updateActual();
                updateObservation();
                xhat = rioStep(xhat);
                updatePrediction(xhat);
                updateResidual();
                print();
            }
        }

        void updatePrediction(RandomVector<N2> xhat) {
            state.predictedPosition = xhat.x.get(0, 0);
            state.predictedVelocity = xhat.x.get(1, 0);
        }

        /**
         * Update the residuals.
         * 
         * The residual should be zero at the *next* filter quantum.
         * Negative error means the data is below the prediction i.e. prediction should
         * be more negative.
         */
        void updateResidual() {
            state.residualPosition = MathUtil.angleModulus(state.actualPosition - state.predictedPosition);
            state.residualVelocity = state.actualVelocity - state.predictedVelocity;
        }

        void print() {
            printRow(state);
        }

        /**
         * Run the roborio code if it's the right time.
         * 
         * This talks to the observer and controller. the goal is to decide what to do
         * for the next quantum, so here we are looking at the future.
         */
        RandomVector<N2> rioStep(RandomVector<N2> xhat) {
            if (state.systemTimeMicrosec % kUsecPerRioLoop == 0) {
                xhat = correctObserver(xhat);
                xhat = predict(xhat);
                Vector<N2> nextReference = nextReference();
                Vector<N2> nextRDot = nextRDot();
                calculateOutput(xhat, nextReference, nextRDot);
            }
            return xhat;
        }

        private RandomVector<N2> yPosition(double yd) {
            Matrix<N2, N1> yx = new Matrix<>(Nat.N2(), Nat.N1());
            yx.set(0, 0, yd); // position
            Matrix<N2, N2> yP = new Matrix<>(Nat.N2(), Nat.N2());
            yP.set(0, 0, 0.1); // TODO: pass variance somehow
            yP.set(1, 1, 1e9); // velocity gets "don't know" variance
            return new RandomVector<>(yx, yP);
        }

        private RandomVector<N2> yVelocity(double yd) {
            Matrix<N2, N1> yx = new Matrix<>(Nat.N2(), Nat.N1());
            yx.set(1, 0, yd); // velocity
            Matrix<N2, N2> yP = new Matrix<>(Nat.N2(), Nat.N2());
            yP.set(0, 0, 1e9); // position gets "don't know" variance
            yP.set(1, 1, 0.1); // TODO: pass variance somehow
            return new RandomVector<>(yx, yP);
        }

        /**
         * Correct the observer with current measurements.
         * 
         * Right now these measurements represent the current instant
         * TODO: add measurement delay
         */
        RandomVector<N2> correctObserver(RandomVector<N2> xhat) {

            RandomVector<N2> x;
            x = pointEstimator.stateForMeasurementWithZeroU(yPosition(state.observedPosition));
            xhat = pooling.fuse(x, xhat);
            x = pointEstimator.stateForMeasurementWithZeroU(yVelocity(state.observedVelocity));
            xhat = pooling.fuse(x, xhat);

            return xhat;
        }

        /** Predict the expected future state. */
        RandomVector<N2> predict(RandomVector<N2> xhat) {
            return predictor.predict(xhat, (Matrix<N1, N1>) VecBuilder.fill(state.controlU), kSecPerRioLoop);
        }

        /**
         * Calculate control output.
         * 
         * compare the future desired state (the reference) and the future expected
         * states (xhat), and produce output to nudge the expectation towards the desire
         *
         * Combines LQR and FF outputs
         * 
         * TODO: actually drive the actual state using this output
         */
        void calculateOutput(RandomVector<N2> nextXhat, Vector<N2> nextReference, Vector<N2> rDot) {
            // this is the predicted future state given the previous control
            Matrix<N1, N1> u = controller.calculate(nextXhat, nextReference);
            Matrix<N1, N1> uff = feedforward.calculateWithRAndRDot(nextReference, rDot);
            state.controlU = u.plus(uff).get(0, 0);
        }

        FeedbackControl<N2, N1, N2> newController() {
            final Vector<N2> stateTolerance = VecBuilder.fill(0.01, 0.01);
            final Vector<N1> controlTolerance = VecBuilder.fill(12.0);
            GainCalculator<N2, N1, N2> gc = new GainCalculator<>(system, stateTolerance, controlTolerance,
                    kSecPerRioLoop);
            Matrix<N1, N2> K = gc.getK();
            return new FeedbackControl<>(system, K);
        }

        void printHeader() {
            System.out.print("     sysTime,   actualTime, ");
            System.out.print("   actualPos,    actualVel,    actualAcc, ");
            System.out.print(" observedPos,  observedVel,  observedAcc, ");
            System.out.print("predictedPos, predictedVel, ");
            System.out.print(" residualPos,  residualVel, ");
            System.out.print("    controlU\n");
        }

        void printRow(CompleteState state) {
            System.out.printf("%12d, %12.3f, ",
                    state.systemTimeMicrosec,
                    state.actualTimeSec());
            System.out.printf("%12.3f, %12.3f, %12.3f, ",
                    state.actualPosition,
                    state.actualVelocity,
                    state.actualAcceleration);
            System.out.printf("%12.3f, %12.3f, %12.3f, ",
                    state.observedPosition,
                    state.observedVelocity,
                    state.observedAcceleration);
            System.out.printf("%12.3f, %12.3f, ",
                    state.predictedPosition,
                    state.predictedVelocity);
            System.out.printf("%12.3f, %12.3f, ",
                    state.residualPosition,
                    state.residualVelocity);
            System.out.printf("%12.3f\n",
                    state.controlU);
        }
    }

    public static class ConstantVelocity extends Scenario {
        private static final double kVelocity = 1.0;

        double position(double timeSec) {
            return MathUtil.angleModulus(kVelocity * timeSec);
        }

        double velocity(double timeSec) {
            return kVelocity;
        }

        double acceleration(double timeSec) {
            return 0;
        }

        void label() {
            System.out.println("\n\nCONSTANT VELOCITY");
        }
    }

    public static class ConstantAcceleration extends Scenario {
        private static final double kAcceleration = 1.0;

        double position(double timeSec) {
            return MathUtil.angleModulus(Math.pow(timeSec, 2) / 2);
        }

        double velocity(double timeSec) {
            return kAcceleration * timeSec;
        }

        double acceleration(double timeSec) {
            return kAcceleration;
        }

        void label() {
            System.out.println("\n\nCONSTANT ACCELERATION");
        }
    }

    public static class Sinusoidal extends Scenario {
        double position(double timeSec) {
            return MathUtil.angleModulus(Math.cos(timeSec));
        }

        double velocity(double timeSec) {
            return -1.0 * Math.sin(timeSec);
        }

        double acceleration(double timeSec) {
            return -1.0 * Math.cos(timeSec);
        }

        void label() {
            System.out.println("\n\nSINUSOIDAL");
        }
    }

    // turning these off for now since they make a lot of output.

    @Test
    public void testConstantVelocity() {
        // new ConstantVelocity().execute();
    }

    @Test
    public void testConstantAcceleration() {
        // new ConstantAcceleration().execute();
    }

    @Test
    public void testSinusoidal() {
        // new Sinusoidal().execute();
    }

}
