package org.team100.lib.estimator;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;
import org.team100.lib.controller.AngleController;
import org.team100.lib.controller.ImmutableControlAffinePlantInversionFeedforward;
import org.team100.lib.system.examples.DoubleIntegrator1D;

import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.Nat;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.Vector;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N2;

/**
 * Illustrates delayed measurements and what to do with them.
 * 
 * TODO: actually delay the measurements. :-)
 * 
 * For the data generated by these tests, look here:
 * 
 * https://docs.google.com/spreadsheets/d/1miehTmvbdRFs49wy2x8u_3SqVKrNw-oJB5Dv5-uQYo0
 * 
 * Timing
 * 
 * Sensor delay has several components:
 * * position sample rate
 * * velocity window width
 * * velocity averaging
 * * reporting rate
 * 
 * Using SparkMax velocity measurement is described here
 * 
 * https://docs.revrobotics.com/sparkmax/software-resources/configuration-parameters
 * 
 * the sparkmax measures velocity with a two-step process.
 * 
 * first it samples velocity using the current position and a past position, and
 * then it averages the past N samples.
 * 
 * the sparkmax takes a position measurement every 500 us.
 * 
 * kEncoderSampleDelta is the number of position measurements to look back.
 * 
 * for the built-in sensor it must be between 8 and 64, default is 32 which
 * means 0.016s between samples.
 * 
 * kEncoderAverageDepth is the number of velocity samples to average.
 * for the built-in sensor it is 1,2,4, or 8 (the default); it just averages the
 * past N samples.
 * 
 * so using the default dt and the default average depth, the edge of the window
 * is 0.128s ago.
 * 
 * The SparkMax reporting frequency is described here:
 * 
 * https://docs.revrobotics.com/sparkmax/operating-modes/control-interfaces
 * 
 * Velocity is reported via CAN as part of Periodic Status 1, which has a
 * default rate of 20ms
 * Position is reported via CAN as part of Periodic Status 2, which has a
 * default rate of 20ms.
 * 
 * these rates can be increased a little, like to 10ms if the rio is running a
 * fast loop.
 * 
 * but for now use 20ms.
 * 
 * assume that the marshalling delay is zero.
 * 
 * Another example of measurement delay is the gyro
 * 
 * https://pdocs.kauailabs.com/navx-mxp/wp-content/uploads/2019/02/navx-mxp_robotics_navigation_sensor_user_guide.pdf
 * 
 * this specifies 1ms latency for the USB interface, and 200Hz sampling, and
 * also suggests that the on-board filter is EKF, which means it should have
 * pretty low latency relative to the sampling frequency?
 * 
 * TODO: extend this to include acceleration, since the gyro provides cartesian
 * accelerations.
 * 
 */
public class EstimatorLatencyTest {
    private static final double kDelta = 0.001;

    private static final long kUsecPerSimLoop = 2000; // 2 ms per simulation loop
    private static final long kUsecPerRioLoop = 20000; // 20 ms per rio loop
    private static final double kSecPerUsec = 1e-6;
    private static final double kSecPerRioLoop = kUsecPerRioLoop * kSecPerUsec;

    public static class CompleteState {
        // int step;
        long systemTimeMicrosec; // from FPGAtime

        double actualTimeSec() {
            return systemTimeMicrosec * kSecPerUsec;
        }

        double actualPosition;
        double actualVelocity;
        double actualAcceleration;

        double observationTimeSec; // valid time this observation represents
        double observedPosition;
        double observedVelocity;
        double observedAcceleration; // for these tests this is intended to match u.

        double predictionTimeSec; // time in the future this prediction is intended for
        double predictedPosition;
        double predictedVelocity;

        double residualPosition;
        double residualVelocity;

        double controlU;
    }

    public static abstract class Scenario {
        final CompleteState state;
        final ExtendedAngleEstimator<N2, N1> observer;
        final ImmutableControlAffinePlantInversionFeedforward<N2, N1, N2> feedforward;
        final AngleController<N2> controller;
        final DoubleIntegrator1D system;

        /**
         * The derivative of state.
         * 
         * x = (position, velocity)
         * xdot = (velocity, control)
         */
        Matrix<N2, N1> f(Matrix<N2, N1> x, Matrix<N1, N1> u) {
            return VecBuilder.fill(x.get(1, 0), u.get(0, 0));
        }

        /**
         * Both measurements: (position, velocity)
         */
        Matrix<N2, N1> h(Matrix<N2, N1> x, Matrix<N1, N1> u) {
            return x;
        }

        public Scenario() {
            system = new DoubleIntegrator1D();
            state = initial();
            observer = newObserver();
            feedforward = new ImmutableControlAffinePlantInversionFeedforward<>(Nat.N2(), Nat.N1(), system);
            controller = newController();
            label();
            printHeader();
        }

        abstract void label();

        abstract double position(double timeSec);

        abstract double velocity(double timeSec);

        abstract double acceleration(double timeSec);

        /**
         * Update the actual state of the physical system.
         */
        void updateActual() {
            state.actualPosition = position(state.actualTimeSec());
            state.actualVelocity = velocity(state.actualTimeSec());
            state.actualAcceleration = acceleration(state.actualTimeSec());
        }

        /**
         * For now, observations are perfect and instantaneous.
         */
        void updateObservation() {
            state.observedPosition = state.actualPosition;
            state.observedVelocity = state.actualVelocity;
            state.observedAcceleration = state.actualAcceleration;
        }

        /**
         * Specify the desired future state.
         */
        Vector<N2> nextReference() {
            // TODO: make this dt/2 for midpoint actuation
            double futureTimeSec = state.actualTimeSec() + kSecPerRioLoop;
            double referencePosition = position(futureTimeSec);
            double referenceVelocity = velocity(futureTimeSec);
            return VecBuilder.fill(referencePosition, referenceVelocity);
        }

        /**
         * analytical future state derivative
         */
        Vector<N2> nextRDot() {
            double futureTimeSec = state.actualTimeSec() + kSecPerRioLoop;
            double referenceVelocity = velocity(futureTimeSec);
            double referenceAcceleration = acceleration(futureTimeSec);
            return VecBuilder.fill(referenceVelocity, referenceAcceleration);
        }

        CompleteState initial() {
            double initialPosition = position(0);
            double initialVelocity = velocity(0);
            double initialAcceleration = acceleration(0);
            CompleteState state = new CompleteState();

            state.systemTimeMicrosec = 0l;
            // state.actualTimeSec = 0;

            state.actualPosition = initialPosition;
            state.actualVelocity = initialVelocity;
            state.actualAcceleration = initialAcceleration;

            state.observedPosition = initialPosition;
            state.observedVelocity = initialVelocity;
            state.observedAcceleration = initialAcceleration;

            state.predictedPosition = initialPosition;
            state.predictedVelocity = initialVelocity;

            state.residualPosition = 0;
            state.residualVelocity = 0;

            state.controlU = initialAcceleration;
            return state;
        }

        void execute() {
            for (long step = 0; step < 2000; ++step) {
                state.systemTimeMicrosec = step * kUsecPerSimLoop;
                updateActual();
                updateObservation();
                rioStep();
                updatePrediction();
                updateResidual();
                print();
            }
        }

        void updatePrediction() {
            state.predictedPosition = observer.getXhat(0);
            state.predictedVelocity = observer.getXhat(1);
        }

        /**
         * Update the residuals.
         * 
         * The residual should be zero at the *next* filter quantum.
         * Negative error means the data is below the prediction i.e. prediction should
         * be more negative.
         */
        void updateResidual() {
            state.residualPosition = MathUtil.angleModulus(state.actualPosition - state.predictedPosition);
            state.residualVelocity = state.actualVelocity - state.predictedVelocity;
        }

        void print() {
            printRow(state);
        }

        /**
         * Run the roborio code if it's the right time.
         * 
         * This talks to the observer and controller. the goal is to decide what to do
         * for the next quantum, so here we are looking at the future.
         */
        void rioStep() {
            if (state.systemTimeMicrosec % kUsecPerRioLoop == 0) {
                correctObserver();
                predict();
                Vector<N2> nextReference = nextReference();
                Vector<N2> nextRDot = nextRDot();
                calculateOutput(nextReference, nextRDot, kSecPerRioLoop);
            }
        }

        /**
         * Correct the observer with current measurements.
         * 
         * Right now these measurements represent the current instant
         * TODO: add measurement delay
         */
        void correctObserver() {
            observer.correctAngle(VecBuilder.fill(state.observedPosition), system.position());
            observer.correctVelocity(VecBuilder.fill(state.observedVelocity), system.velocity());
        }

        /** Predict the expected future state. */
        void predict() {
            observer.predictState((Matrix<N1, N1>) VecBuilder.fill(state.controlU), kSecPerRioLoop);
        }

        /**
         * Calculate control output.
         * 
         * compare the future desired state (the reference) and the future expected
         * states (xhat), and produce output to nudge the expectation towards the desire
         *
         * Combines LQR and FF outputs
         * 
         * TODO: actually drive the actual state using this output
         */
        void calculateOutput(Vector<N2> nextReference, Vector<N2> rDot, double dtSec) {
            // this is the predicted future state given the previous control
            Matrix<N2, N1> nextXhat = observer.getXhat();
            Matrix<N1, N1> u = controller.calculate(nextXhat, nextReference, dtSec);
            Matrix<N1, N1> uff = feedforward.calculateWithRAndRDot(nextReference, rDot);
            state.controlU = u.plus(uff).get(0, 0);
        }

        ExtendedAngleEstimator<N2, N1> newObserver() {
            double initialPosition = position(0);
            double initialVelocity = velocity(0);
            final ExtendedAngleEstimator<N2, N1> observer = new ExtendedAngleEstimator<N2, N1>(
                    Nat.N2(), Nat.N1(),
                    system,
                    VecBuilder.fill(0.1, 0.1),
                    VecBuilder.fill(0.01, 0.01),
                    kSecPerRioLoop);
            observer.reset();
            observer.setXhat(VecBuilder.fill(initialPosition, initialVelocity));
            assertEquals(initialPosition, observer.getXhat(0), kDelta);
            assertEquals(initialVelocity, observer.getXhat(1), kDelta);
            return observer;
        }

        AngleController<N2> newController() {
            final Vector<N2> stateTolerance = VecBuilder.fill(0.01, 0.01);
            final Vector<N1> controlTolerance = VecBuilder.fill(12.0);
            return new AngleController<>(Nat.N2(), system, stateTolerance, controlTolerance);
        }

        void printHeader() {
            System.out.print("     sysTime,   actualTime, ");
            System.out.print("   actualPos,    actualVel,    actualAcc, ");
            System.out.print(" observedPos,  observedVel,  observedAcc, ");
            System.out.print("predictedPos, predictedVel, ");
            System.out.print(" residualPos,  residualVel, ");
            System.out.print("    controlU\n");
        }

        void printRow(CompleteState state) {
            System.out.printf("%12d, %12.3f, ",
                    state.systemTimeMicrosec,
                    state.actualTimeSec());
            System.out.printf("%12.3f, %12.3f, %12.3f, ",
                    state.actualPosition,
                    state.actualVelocity,
                    state.actualAcceleration);
            System.out.printf("%12.3f, %12.3f, %12.3f, ",
                    state.observedPosition,
                    state.observedVelocity,
                    state.observedAcceleration);
            System.out.printf("%12.3f, %12.3f, ",
                    state.predictedPosition,
                    state.predictedVelocity);
            System.out.printf("%12.3f, %12.3f, ",
                    state.residualPosition,
                    state.residualVelocity);
            System.out.printf("%12.3f\n",
                    state.controlU);
        }
    }

    public static class ConstantVelocity extends Scenario {
        private static final double kVelocity = 1.0;

        double position(double timeSec) {
            return MathUtil.angleModulus(kVelocity * timeSec);
        }

        double velocity(double timeSec) {
            return kVelocity;
        }

        double acceleration(double timeSec) {
            return 0;
        }

        void label() {
            System.out.println("\n\nCONSTANT VELOCITY");
        }
    }

    public static class ConstantAcceleration extends Scenario {
        private static final double kAcceleration = 1.0;

        double position(double timeSec) {
            return MathUtil.angleModulus(Math.pow(timeSec, 2) / 2);
        }

        double velocity(double timeSec) {
            return kAcceleration * timeSec;
        }

        double acceleration(double timeSec) {
            return kAcceleration;
        }

        void label() {
            System.out.println("\n\nCONSTANT ACCELERATION");
        }
    }

    public static class Sinusoidal extends Scenario {
        double position(double timeSec) {
            return MathUtil.angleModulus(Math.cos(timeSec));
        }

        double velocity(double timeSec) {
            return -1.0 * Math.sin(timeSec);
        }

        double acceleration(double timeSec) {
            return -1.0 * Math.cos(timeSec);
        }

        void label() {
            System.out.println("\n\nSINUSOIDAL");
        }
    }

    // turning these off for now since they make a lot of output.

    @Test
    public void testConstantVelocity() {
        // new ConstantVelocity().execute();
    }

    @Test
    public void testConstantAcceleration() {
        // new ConstantAcceleration().execute();
    }

    @Test
    public void testSinusoidal() {
        // new Sinusoidal().execute();
    }

}
