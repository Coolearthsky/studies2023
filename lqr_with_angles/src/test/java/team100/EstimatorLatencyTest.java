package team100;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.Nat;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.Vector;
import edu.wpi.first.math.controller.LinearPlantInversionFeedforward;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N2;
import edu.wpi.first.math.system.LinearSystem;

/**
 * Illustrates delayed measurements and what to do with them.
 * 
 * TODO: actually delay the measurements. :-)
 * 
 * For the data generated by these tests, look here:
 * 
 * https://docs.google.com/spreadsheets/d/1miehTmvbdRFs49wy2x8u_3SqVKrNw-oJB5Dv5-uQYo0
 * 
 * Timing
 * 
 * Sensor delay has several components:
 * * position sample rate
 * * velocity window width
 * * velocity averaging
 * * reporting rate
 * 
 * Using SparkMax velocity measurement is described here
 * 
 * https://docs.revrobotics.com/sparkmax/software-resources/configuration-parameters
 * 
 * the sparkmax measures velocity with a two-step process.
 * 
 * first it samples velocity using the current position and a past position, and
 * then it averages the past N samples.
 * 
 * the sparkmax takes a position measurement every 500 us.
 * 
 * kEncoderSampleDelta is the number of position measurements to look back.
 * 
 * for the built-in sensor it must be between 8 and 64, default is 32 which
 * means 0.016s between samples.
 * 
 * kEncoderAverageDepth is the number of velocity samples to average.
 * for the built-in sensor it is 1,2,4, or 8 (the default); it just averages the
 * past N samples.
 * 
 * so using the default dt and the default average depth, the edge of the window
 * is 0.128s ago.
 * 
 * The SparkMax reporting frequency is described here:
 * 
 * https://docs.revrobotics.com/sparkmax/operating-modes/control-interfaces
 * 
 * Velocity is reported via CAN as part of Periodic Status 1, which has a
 * default rate of 20ms
 * Position is reported via CAN as part of Periodic Status 2, which has a
 * default rate of 20ms.
 * 
 * these rates can be increased a little, like to 10ms if the rio is running a
 * fast loop.
 * 
 * but for now use 20ms.
 * 
 * assume that the marshalling delay is zero.
 * 
 */
public class EstimatorLatencyTest {
    private static final double kDelta = 0.001;
    private static final double actualTimeQuantum = 0.002;
    private static final int stepsPerFilterQuantum = 10;
    private static final double filterTimeQuantum = actualTimeQuantum * stepsPerFilterQuantum;

    public static class CompleteState {
        int step;
        double actualTime;

        double actualPosition;
        double actualVelocity;
        double actualAcceleration;

        double observedPosition;
        double observedVelocity;
        double observedAcceleration;

        double predictedPosition;
        double predictedVelocity;

        double residualPosition;
        double residualVelocity;

        double controlU;
    }

    public static abstract class Scenario {
        final CompleteState state;
        final AngleEstimator observer;
        final LinearSystem<N2, N1, N2> plant;
        final LinearPlantInversionFeedforward<N2, N1, N2> feedforward;
        final AngleController controller;

        public Scenario(double initialPosition, double initialVelocity, double initialAcceleration) {
            state = initial(initialPosition, initialVelocity, initialAcceleration);
            observer = newObserver(initialPosition, initialVelocity);
            plant = newPlant();
            feedforward = new LinearPlantInversionFeedforward<>(plant, filterTimeQuantum);
            feedforward.calculate(VecBuilder.fill(initialPosition, initialVelocity));
            controller = newController(plant);

            label();
            printHeader();
        }

        abstract void label();

        /**
         * Specify the desired future state. (here we expect constant velocity but it
         * could be, say, a trajectory or trapezoid.)
         */
        abstract Vector<N2> nextReference();

        /**
         * Update the actual state of the physical system.
         */
        abstract void updateActual();

        CompleteState initial(double initialPosition, double initialVelocity, double initialAcceleration) {
            CompleteState state = new CompleteState();

            state.actualTime = 0;

            state.actualPosition = initialPosition;
            state.actualVelocity = initialVelocity;
            state.actualAcceleration = initialAcceleration;

            state.observedPosition = initialPosition;
            state.observedVelocity = initialVelocity;
            state.observedAcceleration = initialAcceleration;

            state.predictedPosition = initialPosition;
            state.predictedVelocity = initialVelocity;

            state.residualPosition = 0;
            state.residualVelocity = 0;

            state.controlU = initialAcceleration;
            return state;
        }

        void execute() {
            for (state.step = 0; state.step < 2000; ++state.step) {
                state.actualTime = state.step * actualTimeQuantum;
                updateActual();
                updateObservation();
                rioStep();
                updatePrediction();
                updateResidual();
                print();
            }
        }

        void updatePrediction() {
            state.predictedPosition = observer.getXhat(0);
            state.predictedVelocity = observer.getXhat(1);
        }

        /**
         * Update the residuals.
         * 
         * The residual should be zero at the *next* filter quantum.
         * Negative error means the data is below the prediction i.e. prediction should
         * be more negative.
         */
        void updateResidual() {

            state.residualPosition = MathUtil
                    .angleModulus(state.actualPosition - state.predictedPosition);
            state.residualVelocity = state.actualVelocity - state.predictedVelocity;
        }

        void print() {
            printRow(state);
        }

        /**
         * Run the roborio code if it's the right time.
         * 
         * This talks to the observer and controller. the goal is to decide what to do
         * for the next quantum, so here we are looking at the future.
         */
        void rioStep() {
            if (state.step % stepsPerFilterQuantum == 0) {
                correctObserver();
                predict();
                Vector<N2> nextReference = nextReference();
                calculateOutput(nextReference);
            }
        }

        /** For now, observations are perfect and instantaneous. */
        void updateObservation() {
            state.observedPosition = state.actualPosition;
            state.observedVelocity = state.actualVelocity;
            state.observedAcceleration = state.actualAcceleration;
        }

        /**
         * correct the observer with current measurements.
         * right now these measurements represent the current instant
         * TODO: add measurement delay
         */
        void correctObserver() {
            observer.correctAngle(state.controlU, state.observedPosition);
            observer.correctVelocity(state.controlU, state.observedVelocity);
        }

        /** predict the expected future state. */
        void predict() {
            observer.predictState(state.controlU, filterTimeQuantum);
        }

        /**
         * Calculate control output.
         * 
         * compare the future desired state (the reference) and the future expected
         * states (xhat), and produce output to nudge the expectation towards the desire
         *
         * Combines LQR and FF outputs
         * 
         * TODO: actually drive the actual state using this output
         */
        void calculateOutput(Vector<N2> nextReference) {
            // this is the predicted future state given the previous control
            Matrix<N2, N1> nextXhat = observer.getXhat();
            controller.calculate(nextXhat, nextReference);
            Matrix<N1, N1> u = controller.getU();
            Matrix<N1, N1> uff = feedforward.calculate(nextReference);
            state.controlU = u.plus(uff).get(0, 0);
        }

        AngleEstimator newObserver(double initialPosition, double initialVelocity) {
            final AngleEstimator observer = new AngleEstimator(
                    VecBuilder.fill(0.1, 0.1),
                    VecBuilder.fill(0.01, 0.01),
                    filterTimeQuantum);
            observer.reset();
            observer.setXhat(VecBuilder.fill(initialPosition, initialVelocity));
            assertEquals(initialPosition, observer.getXhat(0), kDelta);
            assertEquals(initialVelocity, observer.getXhat(1), kDelta);
            return observer;
        }

        LinearSystem<N2, N1, N2> newPlant() {
            final Matrix<N2, N2> A = Matrix.mat(Nat.N2(), Nat.N2()).fill(0, 1, 0, 0);
            final Matrix<N2, N1> B = Matrix.mat(Nat.N2(), Nat.N1()).fill(0, 1);
            final Matrix<N2, N2> C = Matrix.mat(Nat.N2(), Nat.N2()).fill(1, 0, 0, 1);
            final Matrix<N2, N1> D = Matrix.mat(Nat.N2(), Nat.N1()).fill(0, 0);
            final LinearSystem<N2, N1, N2> plant = new LinearSystem<>(A, B, C, D);
            return plant;
        }

        AngleController newController(LinearSystem<N2, N1, N2> plant) {
            final Vector<N2> stateTolerance = VecBuilder.fill(0.01, 0.01);
            final Vector<N1> controlTolerance = VecBuilder.fill(12.0);
            final AngleController controller = new AngleController(
                    plant,
                    stateTolerance,
                    controlTolerance,
                    filterTimeQuantum);
            controller.reset();
            assertEquals(49, controller.getK().get(0, 0), 1.0);
            assertEquals(50, controller.getK().get(0, 1), 1.0);
            return controller;
        }

        void printHeader() {
            System.out.print("        step,   actualTime, ");
            System.out.print("   actualPos,    actualVel,    actualAcc, ");
            System.out.print(" observedPos,  observedVel,  observedAcc, ");
            System.out.print("predictedPos, predictedVel, ");
            System.out.print(" residualPos,  residualVel, ");
            System.out.print("    controlU\n");
        }

        void printRow(CompleteState state) {
            System.out.printf("%12d, %12.3f, ",
                    state.step,
                    state.actualTime);
            System.out.printf("%12.3f, %12.3f, %12.3f, ",
                    state.actualPosition,
                    state.actualVelocity,
                    state.actualAcceleration);
            System.out.printf("%12.3f, %12.3f, %12.3f, ",
                    state.observedPosition,
                    state.observedVelocity,
                    state.observedAcceleration);
            System.out.printf("%12.3f, %12.3f, ",
                    state.predictedPosition,
                    state.predictedVelocity);
            System.out.printf("%12.3f, %12.3f, ",
                    state.residualPosition,
                    state.residualVelocity);
            System.out.printf("%12.3f\n",
                    state.controlU);
        }
    }

    public static class ConstantVelocity extends Scenario {
        public ConstantVelocity() {
            super(0, 1, 0);
        }

        void label() {
            System.out.println("\n\nCONSTANT VELOCITY");
        }

        void updateActual() {
            state.actualAcceleration = 0;
            state.actualVelocity = 1;
            state.actualPosition = MathUtil
                    .angleModulus(state.actualVelocity * state.actualTime);

        }

        Vector<N2> nextReference() {
            double setpointPosition = MathUtil
                    .angleModulus(state.actualVelocity * (state.actualTime + filterTimeQuantum));
            double setpointVelocity = 1;
            Vector<N2> setpoint = VecBuilder.fill(setpointPosition, setpointVelocity);
            return setpoint;
        }

    }

    public static class ConstantAcceleration extends Scenario {
        public ConstantAcceleration() {
            super(0, 0, 1);
        }

        void label() {
            System.out.println("\n\nCONSTANT ACCELERATION");
        }

        void updateActual() {
            state.actualAcceleration = 1;
            state.actualVelocity = state.actualAcceleration * state.actualTime;
            state.actualPosition = MathUtil.angleModulus(Math.pow(state.actualTime, 2) / 2);
        }

        Vector<N2> nextReference() {
            double setpointPosition = Math.pow(state.actualTime + filterTimeQuantum, 2) / 2;
            double setpointVelocity = state.actualTime + filterTimeQuantum;
            Vector<N2> setpoint = VecBuilder.fill(setpointPosition, setpointVelocity);
            return setpoint;
        }

    }

    public static class Sinusoidal extends Scenario {
        public Sinusoidal() {
            super(1, 0, -1);
        }

        void label() {
            System.out.println("\n\nSINUSOIDAL");
        }

        void updateActual() {
            state.actualAcceleration = -1.0 * Math.cos(state.actualTime);
            state.actualVelocity = -1.0 * Math.sin(state.actualTime);
            state.actualPosition = MathUtil.angleModulus(Math.cos(state.actualTime));
        }

        Vector<N2> nextReference() {
            double setpointPosition = MathUtil
                    .angleModulus(Math.cos(state.actualTime + filterTimeQuantum));
            double setpointVelocity = -1.0 * Math.sin(state.actualTime + filterTimeQuantum);
            Vector<N2> setpoint = VecBuilder.fill(setpointPosition, setpointVelocity);
            return setpoint;
        }
    }

    /** Constant velocity means no torque so no controller output. */
    @Test
    public void testConstantVelocity() {
        Scenario scenario = new ConstantVelocity();
        scenario.execute();
    }

    @Test
    public void testConstantAcceleration() {
        Scenario scenario = new ConstantAcceleration();
        scenario.execute();
    }

    @Test
    public void testSinusoidal() {
        Scenario scenario = new Sinusoidal();
        scenario.execute();
    }

}
