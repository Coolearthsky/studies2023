package team100;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.Nat;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.Vector;
import edu.wpi.first.math.controller.LinearPlantInversionFeedforward;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N2;
import edu.wpi.first.math.system.LinearSystem;

/**
 * Illustrates delayed measurements and what to do with them.
 * 
 * TODO: actually delay the measurements. :-)
 * 
 * For the data generated by these tests, look here:
 * 
 * https://docs.google.com/spreadsheets/d/1miehTmvbdRFs49wy2x8u_3SqVKrNw-oJB5Dv5-uQYo0
 * 
 * Timing
 * 
 * Sensor delay has several components:
 * * position sample rate
 * * velocity window width
 * * velocity averaging
 * * reporting rate
 * 
 * Using SparkMax velocity measurement is described here
 * 
 * https://docs.revrobotics.com/sparkmax/software-resources/configuration-parameters
 * 
 * the sparkmax measures velocity with a two-step process.
 * 
 * first it samples velocity using the current position and a past position, and
 * then it averages the past N samples.
 * 
 * the sparkmax takes a position measurement every 500 us.
 * 
 * kEncoderSampleDelta is the number of position measurements to look back.
 * 
 * for the built-in sensor it must be between 8 and 64, default is 32 which
 * means 0.016s between samples.
 * 
 * kEncoderAverageDepth is the number of velocity samples to average.
 * for the built-in sensor it is 1,2,4, or 8 (the default); it just averages the
 * past N samples.
 * 
 * so using the default dt and the default average depth, the edge of the window
 * is 0.128s ago.
 * 
 * The SparkMax reporting frequency is described here:
 * 
 * https://docs.revrobotics.com/sparkmax/operating-modes/control-interfaces
 * 
 * Velocity is reported via CAN as part of Periodic Status 1, which has a
 * default rate of 20ms
 * Position is reported via CAN as part of Periodic Status 2, which has a
 * default rate of 20ms.
 * 
 * these rates can be increased a little, like to 10ms if the rio is running a
 * fast loop.
 * 
 * but for now use 20ms.
 * 
 * assume that the marshalling delay is zero.
 * 
 */
public class EstimatorLatencyTest {
    private static final double kDelta = 0.001;
    private static final double actualTimeQuantum = 0.002;
    private static final int stepsPerFilterQuantum = 10;
    private static final double filterTimeQuantum = actualTimeQuantum * stepsPerFilterQuantum;

    public static class CompleteState {
        int step;
        double actualTime;

        double actualPosition;
        double actualVelocity;
        double actualAcceleration;

        double observedPosition;
        double observedVelocity;
        double observedAcceleration;

        double predictedPosition;
        double predictedVelocity;

        double residualPosition;
        double residualVelocity;

        double controlU;
    }

    public static abstract class Scenario {
        final CompleteState state;
        final AngleEstimator observer;
        final LinearSystem<N2, N1, N2> plant;
        final LinearPlantInversionFeedforward<N2, N1, N2> feedforward;
        final AngleController controller;

        public Scenario(double initialPosition, double initialVelocity, double initialAcceleration) {
            state = initial(initialPosition, initialVelocity, initialAcceleration);
            observer = newObserver(initialPosition, initialVelocity);
            plant = newPlant();
            feedforward = new LinearPlantInversionFeedforward<>(plant, filterTimeQuantum);
            feedforward.calculate(VecBuilder.fill(initialPosition, initialVelocity));
            controller = newController(plant);

            label();
            printHeader();
        }

        abstract void label();

        CompleteState initial(double initialPosition, double initialVelocity, double initialAcceleration) {
            CompleteState state = new CompleteState();

            state.actualTime = 0;

            state.actualPosition = initialPosition;
            state.actualVelocity = initialVelocity;
            state.actualAcceleration = initialAcceleration;

            state.observedPosition = initialPosition;
            state.observedVelocity = initialVelocity;
            state.observedAcceleration = initialAcceleration;

            state.predictedPosition = initialPosition;
            state.predictedVelocity = initialVelocity;

            state.residualPosition = 0;
            state.residualVelocity = 0;

            state.controlU = initialAcceleration;
            return state;
        }

        void updatePrediction() {
            state.predictedPosition = observer.getXhat(0);
            state.predictedVelocity = observer.getXhat(1);
        }
        void updateResidual() {
                        // the errors should be zero at the *next* filter quantum.
            // note negative error means the data is below the prediction i.e. prediction
            // should be more negative
            state.residualPosition = MathUtil
                    .angleModulus(state.actualPosition - state.predictedPosition);
            state.residualVelocity = state.actualVelocity - state.predictedVelocity;
        }

        void print() {
            printRow(state);
        }

        /** For now, observations are perfect and instantaneous. */
        void updateObservation() {
            state.observedPosition = state.actualPosition;
            state.observedVelocity = state.actualVelocity;
            state.observedAcceleration = state.actualAcceleration;

        }

        AngleEstimator newObserver(double initialPosition, double initialVelocity) {
            final AngleEstimator observer = new AngleEstimator(
                    VecBuilder.fill(0.1, 0.1),
                    VecBuilder.fill(0.01, 0.01),
                    filterTimeQuantum);
            observer.reset();
            observer.setXhat(VecBuilder.fill(initialPosition, initialVelocity));
            assertEquals(initialPosition, observer.getXhat(0), kDelta);
            assertEquals(initialVelocity, observer.getXhat(1), kDelta);
            return observer;
        }

        LinearSystem<N2, N1, N2> newPlant() {
            final Matrix<N2, N2> A = Matrix.mat(Nat.N2(), Nat.N2()).fill(0, 1, 0, 0);
            final Matrix<N2, N1> B = Matrix.mat(Nat.N2(), Nat.N1()).fill(0, 1);
            final Matrix<N2, N2> C = Matrix.mat(Nat.N2(), Nat.N2()).fill(1, 0, 0, 1);
            final Matrix<N2, N1> D = Matrix.mat(Nat.N2(), Nat.N1()).fill(0, 0);
            final LinearSystem<N2, N1, N2> plant = new LinearSystem<>(A, B, C, D);
            return plant;
        }

        AngleController newController(LinearSystem<N2, N1, N2> plant) {
            final Vector<N2> stateTolerance = VecBuilder.fill(0.01, 0.01);
            final Vector<N1> controlTolerance = VecBuilder.fill(12.0);
            final AngleController controller = new AngleController(
                    plant,
                    stateTolerance,
                    controlTolerance,
                    filterTimeQuantum);
            controller.reset();
            assertEquals(49, controller.getK().get(0, 0), 1.0);
            assertEquals(50, controller.getK().get(0, 1), 1.0);
            return controller;
        }

        void printHeader() {
            System.out.print("        step,   actualTime, ");
            System.out.print("   actualPos,    actualVel,    actualAcc, ");
            System.out.print(" observedPos,  observedVel,  observedAcc, ");
            System.out.print("predictedPos, predictedVel, ");
            System.out.print(" residualPos,  residualVel, ");
            System.out.print("    controlU\n");
        }

        void printRow(CompleteState state) {
            System.out.printf("%12d, %12.3f, ",
                    state.step,
                    state.actualTime);
            System.out.printf("%12.3f, %12.3f, %12.3f, ",
                    state.actualPosition,
                    state.actualVelocity,
                    state.actualAcceleration);
            System.out.printf("%12.3f, %12.3f, %12.3f, ",
                    state.observedPosition,
                    state.observedVelocity,
                    state.observedAcceleration);
            System.out.printf("%12.3f, %12.3f, ",
                    state.predictedPosition,
                    state.predictedVelocity);
            System.out.printf("%12.3f, %12.3f, ",
                    state.residualPosition,
                    state.residualVelocity);
            System.out.printf("%12.3f\n",
                    state.controlU);
        }
    }

    public static class ConstantVelocity extends Scenario {
        public ConstantVelocity() {
            super(0, 1, 0);
        }

        void label() {
            System.out.println("\n\nCONSTANT VELOCITY");
        }

    }

    /** Constant velocity means no torque so no controller output. */
    @Test
    public void testConstantVelocity() {
        Scenario scenario = new ConstantVelocity();

        for (scenario.state.step = 0; scenario.state.step < 2000; ++scenario.state.step) {
            scenario.state.actualTime = scenario.state.step * actualTimeQuantum;

            scenario.state.actualAcceleration = 0;
            scenario.state.actualVelocity = 1;
            scenario.state.actualPosition = MathUtil
                    .angleModulus(scenario.state.actualVelocity * scenario.state.actualTime);

            scenario.updateObservation();

            if (scenario.state.step % stepsPerFilterQuantum == 0) {
                // talk to the observer and controller periodically
                // the goal is to decide what to do for the next quantum,
                // so here we are looking at the future.

                // 1. correct the observer with current measurements.
                // right now these measurements represent the current instant
                // TODO: add measurement delay
                scenario.observer.correctAngle(scenario.state.controlU, scenario.state.observedPosition);
                scenario.observer.correctVelocity(scenario.state.controlU, scenario.state.observedVelocity);

                // 2. predict the expected future state.
                scenario.observer.predictState(scenario.state.controlU, filterTimeQuantum);

                // this is the predicted future state given the previous control
                Matrix<N2, N1> nextXhat = scenario.observer.getXhat();

                // 3. specify the desired future state.
                // (here we expect constant velocity but it could be, say, a trajectory or
                // trapezoid.)
                double setpointPosition = MathUtil
                        .angleModulus(scenario.state.actualVelocity * (scenario.state.actualTime + filterTimeQuantum));
                double setpointVelocity = 1;
                Vector<N2> setpoint = VecBuilder.fill(setpointPosition, setpointVelocity);

                // 4. calculate control output.
                // compare the desired and expected states, and produce output to nudge the
                // expectation towards the desire
                // TODO: actually drive the actual state using this output
                scenario.controller.calculate(nextXhat, setpoint);

                // combine LQR and FF
                Matrix<N1, N1> u = scenario.controller.getU();
                Matrix<N1, N1> uff = scenario.feedforward.calculate(setpoint);
                scenario.state.controlU = u.plus(uff).get(0, 0);
            }
            scenario.updatePrediction();
            scenario.updateResidual();
            scenario.print();
        }
    }

    public static class ConstantAcceleration extends Scenario {

        public ConstantAcceleration() {
            super(0, 0, 1);
        }

        void label() {
            System.out.println("\n\nCONSTANT ACCELERATION");
        }

    }

    @Test
    public void testConstantAcceleration() {
        Scenario scenario = new ConstantAcceleration();

        for (scenario.state.step = 0; scenario.state.step < 2000; ++scenario.state.step) {
            scenario.state.actualTime = scenario.state.step * actualTimeQuantum;

            scenario.state.actualAcceleration = 1;
            scenario.state.actualVelocity = scenario.state.actualAcceleration * scenario.state.actualTime;
            scenario.state.actualPosition = MathUtil.angleModulus(Math.pow(scenario.state.actualTime, 2) / 2);

            scenario.updateObservation();

            if (scenario.state.step % stepsPerFilterQuantum == 0) {
                // talk to the observer and controller periodically
                // the goal is to decide what to do for the next quantum,
                // so here we are looking at the future.

                // 1. correct the observer with current measurements.
                // right now these measurements represent the current instant
                // (TODO: add measurement delay)
                scenario.observer.correctAngle(scenario.state.controlU, scenario.state.observedPosition);
                scenario.observer.correctVelocity(scenario.state.controlU, scenario.state.observedVelocity);

                // 2. predict the expected future state.
                scenario.observer.predictState(scenario.state.controlU, filterTimeQuantum);

                // this is the predicted future state given the previous control
                Matrix<N2, N1> nextXhat = scenario.observer.getXhat();

                // 3. specify the desired future state.
                // (here we magically apply the actual state)
                double setpointPosition = Math.pow(scenario.state.actualTime + filterTimeQuantum, 2) / 2;
                double setpointVelocity = scenario.state.actualTime + filterTimeQuantum;
                Vector<N2> setpoint = VecBuilder.fill(setpointPosition, setpointVelocity);

                // 4. calculate control output.
                // compare the desired and expected states, and produce output to nudge the
                // expectation towards the desire
                // TODO: actually drive the actual state using this output
                scenario.controller.calculate(nextXhat, setpoint);

                // combine LQR and FF
                Matrix<N1, N1> u = scenario.controller.getU();
                Matrix<N1, N1> uff = scenario.feedforward.calculate(setpoint);
                scenario.state.controlU = u.plus(uff).get(0, 0);
            }
            scenario.updatePrediction();
            scenario.updateResidual();
            scenario.print();
        }
    }

    public static class Sinusoidal extends Scenario {
        public Sinusoidal() {
            super(1, 0, -1);
        }

        void label() {
            System.out.println("\n\nSINUSOIDAL");
        }

    }

    @Test
    public void testSinusoidal() {
        Scenario scenario = new Sinusoidal();

        for (scenario.state.step = 0; scenario.state.step < 2000; ++scenario.state.step) {
            scenario.state.actualTime = scenario.state.step * actualTimeQuantum;

            scenario.state.actualAcceleration = -1.0 * Math.cos(scenario.state.actualTime);
            scenario.state.actualVelocity = -1.0 * Math.sin(scenario.state.actualTime);
            scenario.state.actualPosition = MathUtil.angleModulus(Math.cos(scenario.state.actualTime));

            scenario.updateObservation();

            if (scenario.state.step % stepsPerFilterQuantum == 0) {
                // talk to the observer and controller periodically
                // the goal is to decide what to do for the next quantum,
                // so here we are looking at the future.

                // 1. correct the observer with current measurements.
                // right now these measurements represent the current instant
                // (TODO: add measurement delay)
                scenario.observer.correctAngle(scenario.state.controlU, scenario.state.observedPosition);
                scenario.observer.correctVelocity(scenario.state.controlU, scenario.state.observedVelocity);

                // 2. predict the expected future state.
                scenario.observer.predictState(scenario.state.controlU, filterTimeQuantum);

                // this is the predicted future state given the previous control
                Matrix<N2, N1> nextXhat = scenario.observer.getXhat();

                // 3. specify the desired future state.
                // (here we magically apply the actual state)
                double setpointPosition = MathUtil
                        .angleModulus(Math.cos(scenario.state.actualTime + filterTimeQuantum));
                double setpointVelocity = -1.0 * Math.sin(scenario.state.actualTime + filterTimeQuantum);
                Vector<N2> setpoint = VecBuilder.fill(setpointPosition, setpointVelocity);

                // 4. calculate control output.
                // compare the desired and expected states, and produce output to nudge the
                // expectation towards the desire
                // TODO: actually drive the actual state using this output
                scenario.controller.calculate(nextXhat, setpoint);

                // combine LQR and FF
                Matrix<N1, N1> u = scenario.controller.getU();
                Matrix<N1, N1> uff = scenario.feedforward.calculate(setpoint);
                scenario.state.controlU = u.plus(uff).get(0, 0);
            }

            scenario.updatePrediction();
            scenario.updateResidual();
            scenario.print();
        }
    }

}
